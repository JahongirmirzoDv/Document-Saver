package uz.mobiledv.test1.screens // Or your preferred package

// Assuming you have a FilePicker expect/actual or a common file picking mechanism
// import uz.mobiledv.test1.util.FilePicker ( hypothetical )
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import io.github.jan.supabase.SupabaseClient
import io.github.jan.supabase.auth.auth
import io.github.jan.supabase.postgrest.postgrest
import io.github.jan.supabase.postgrest.query.filter.FilterOperator
import io.github.jan.supabase.storage.storage
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import kotlinx.datetime.Clock
import uz.mobiledv.test1.di.BUCKET
import uz.mobiledv.test1.model.Document
import uz.mobiledv.test1.model.Folder

// Sealed class to represent UI State
sealed class FoldersUiState {
    data object Idle : FoldersUiState()
    data object Loading : FoldersUiState()
    data class Success(val folders: List<Folder>) : FoldersUiState()
    data class Error(val message: String) : FoldersUiState()
}

sealed class FolderDocumentsUiState {
    data object Idle : FolderDocumentsUiState()
    data object Loading : FolderDocumentsUiState()
    data class Success(val documents: List<Document>) : FolderDocumentsUiState()
    data class Error(val message: String) : FolderDocumentsUiState()
}


class FoldersViewModel(
    private val supabaseClient: SupabaseClient
) : ViewModel() {

    private val _foldersUiState = MutableStateFlow<FoldersUiState>(FoldersUiState.Idle)
    val foldersUiState: StateFlow<FoldersUiState> = _foldersUiState.asStateFlow()

    private val _folderDocumentsUiState =
        MutableStateFlow<FolderDocumentsUiState>(FolderDocumentsUiState.Idle)
    val folderDocumentsUiState: StateFlow<FolderDocumentsUiState> =
        _folderDocumentsUiState.asStateFlow()


    private val _operationStatus = MutableStateFlow<String?>(null) // For Snackbar messages
    val operationStatus: StateFlow<String?> = _operationStatus.asStateFlow()

    init {
        loadFolders()
    }

    fun loadFolders() {
        viewModelScope.launch {
            _foldersUiState.value = FoldersUiState.Loading
            try {
                val currentUserId = supabaseClient.auth.currentUserOrNull()?.id
                if (currentUserId == null) {
                    _foldersUiState.value = FoldersUiState.Error("User not authenticated.")
                    return@launch
                }
                val folders = supabaseClient.postgrest["folders"]
                    .select {
                        filter({
                            filter("user_id", FilterOperator.EQ, currentUserId)
                        })
                    }
                    .decodeList<Folder>()
                _foldersUiState.value = FoldersUiState.Success(folders)
            } catch (e: Exception) {
                _foldersUiState.value = FoldersUiState.Error("Error loading folders: ${e.message}")
                _operationStatus.value = "Failed to load folders: ${e.message}"
                e.printStackTrace()
            }
        }
    }

    fun createFolder(name: String, description: String) {
        viewModelScope.launch {
            try {
                val currentUserId = supabaseClient.auth.currentUserOrNull()?.id
                if (currentUserId == null) {
                    _operationStatus.value = "Cannot create folder: User not authenticated."
                    return@launch
                }
                val newFolder = Folder(
                    // id will be generated by Supabase if it's a UUID primary key with a default value
                    name = name,
                    description = description,
                    userId = currentUserId,
                    createdAt = Clock.System.now().toString() // Or let Supabase handle timestamping
                )
                supabaseClient.postgrest["folders"].insert(newFolder)
                _operationStatus.value = "Folder '$name' created successfully."
                loadFolders() // Refresh the list
            } catch (e: Exception) {
                _operationStatus.value = "Error creating folder: ${e.message}"
                e.printStackTrace()
            }
        }
    }

    fun updateFolder(folderId: String, name: String, description: String) {
        viewModelScope.launch {
            try {
                supabaseClient.postgrest["folders"]
                    .update({
                        set("name", name)
                        set("description", description)
                    }) {
                        filter(
                            {
                                "id"
                                FilterOperator.EQ
                                folderId
                            }
                        )
                    }
                _operationStatus.value = "Folder '$name' updated successfully."
                loadFolders() // Refresh list
            } catch (e: Exception) {
                _operationStatus.value = "Error updating folder: ${e.message}"
                e.printStackTrace()
            }
        }
    }

    fun deleteFolder(folderId: String) {
        viewModelScope.launch {
            try {
                // Optional: First delete all documents within this folder from storage and database if necessary
                // This depends on your cascade rules in Supabase or if you want to handle it explicitly

                supabaseClient.postgrest["folders"]
                    .delete {
                        filter(
                            {
                                "id"
                                FilterOperator.EQ
                                folderId
                            }
                        )
                    }
                _operationStatus.value = "Folder deleted successfully."
                loadFolders() // Refresh the list
            } catch (e: Exception) {
                _operationStatus.value = "Error deleting folder: ${e.message}"
                e.printStackTrace()
            }
        }
    }

    fun loadDocumentsForFolder(folderId: String) {
        viewModelScope.launch {
            _folderDocumentsUiState.value = FolderDocumentsUiState.Loading
            try {
                val currentUserId = supabaseClient.auth.currentUserOrNull()?.id
                if (currentUserId == null) {
                    _folderDocumentsUiState.value =
                        FolderDocumentsUiState.Error("User not authenticated.")
                    return@launch
                }
                val documents = supabaseClient.postgrest["documents"]
                    .select {
                        filter(
                            {
                                "folder_id"
                                FilterOperator.EQ
                                folderId
                            }
                        )
                        // Add user_id filter if documents are also user-specific directly
                        // filter("user_id", io.github.jan.supabase.postgrest.query.FilterOperator.EQ, currentUserId)
                    }
                    .decodeList<Document>()
                _folderDocumentsUiState.value = FolderDocumentsUiState.Success(documents)
            } catch (e: Exception) {
                _folderDocumentsUiState.value =
                    FolderDocumentsUiState.Error("Error loading documents: ${e.message}")
                _operationStatus.value = "Failed to load documents: ${e.message}"
                e.printStackTrace()
            }
        }
    }


    // Placeholder for file uploading logic
    // You'll need a way to get file bytes and name, potentially via a platform-specific file picker
    fun uploadFileToFolder(
        folderId: String,
        fileName: String,
        fileBytes: ByteArray,
        mimeType: String
    ) {
        viewModelScope.launch {
            val currentUserId = supabaseClient.auth.currentUserOrNull()?.id
            if (currentUserId == null) {
                _operationStatus.value = "Cannot upload file: User not authenticated."
                return@launch
            }

            // Construct a unique path in Supabase Storage, e.g., "user_id/folder_id/file_name"
            // Ensure folderId and potentially userId are part of the path to avoid collisions
            // and to help with organizing files if you browse storage directly.
            val storagePath = "${currentUserId}/${folderId}/${fileName}"

            try {
                // Upload to Supabase Storage
                // Ensure BUCKET constant is defined in your supabaseModule.kt or accessible here
                supabaseClient.storage[BUCKET].upload(
                    path = storagePath,
                    data = fileBytes,
                    options = {} // Set to true to overwrite if file with same path exists
                )

                // After successful upload, create a metadata entry in your 'documents' table
                val documentMetadata = Document(
                    folderId = folderId,
                    name = fileName,
                    storageFilePath = storagePath,
                    userId = currentUserId,
                    mimeType = mimeType,
                    createdAt = Clock.System.now().toString()
                )

                supabaseClient.postgrest["documents"].insert(documentMetadata)

                _operationStatus.value = "File '$fileName' uploaded successfully to folder."
                // Optionally, refresh documents list for the current folder if one is active
                loadDocumentsForFolder(folderId) // If you have a documents view
            } catch (e: Exception) {
                _operationStatus.value = "Error uploading file '$fileName': ${e.message}"
                e.printStackTrace()
                // Consider deleting from storage if database insert fails to avoid orphaned files
                // supabaseClient.storage[BUCKET].delete(storagePath)
            }
        }
    }


    fun clearOperationStatus() {
        _operationStatus.value = null
    }
}